#Алгоритмы сортировки


# Пузырьковая сортировка работает путем многократного прохода по массиву,
# сравнивая соседние элементы и меняя их местами, если они находятся в неправильном порядке.
# Процесс продолжается до тех пор, пока массив не будет отсортирован.
mas = [5, 7, 4, 3, 8, 2]
n = 6
for run in range(n-1): # задаем количество проходов по списку
    for i in range(n-1-run):# перебираем соседние пары чисел;
#мы будем уменьшать количество элементов, которые нужно проверять на каждом следующем проходе,
# поскольку каждый раз один элемент уже оказывается на своём правильном месте.
# Таким образом, нам нужно будет пройти не до конца массива, а до элемента, который находится перед уже отсортированными элементами.
# Для этого добавим -run ко второму циклу for
        if mas[i] > mas[i+1]:
            mas[i], mas[i+1] = mas[i+1], mas[i]
print(mas)






# Быстрая сортировка использует метод «разделяй и властвуй».
# Она выбирает опорный элемент (pivot) и разделяет массив на две части: элементы меньше опорного и элементы больше опорного.
# Затем сортировка применяется рекурсивно к каждой части.

def quick_sort(s):
    if len (s) <= 1:
        return s
    element = s[0] # Выбираем опорный элемент element → указываем индекс 0
#Создаем левую и правую стороны, а также центр

    left = list(filter(lambda i: i < element, s))
# используем filter — это встроенная функция Рython, которая используется для фильтрации элементов из списка на основе определенного условия
# пропишем условие для левой части, при котором в списке будут элементы меньше опорного (lambda i: i < element).и укажем переменную s

    center = list(filter(lambda i: i == element, s))
# либо, используем генератор списков: пропишем [i for i in ], выберем список s, пропишем для него условие: если i равен опорному элементу, то он добавляется в список.
# В итоге: center = [i for i in s if i == element]. Это можно использовать и для левой/правой стороны.
    right = list(filter(lambda i: i > element, s))

    return quick_sort(left)+center+quick_sort(right) # Добавим рекурсию
#Рекурсия необходима при обработке каждой внутренней части структуры данных независимо.
# Это позволяет работать с любым количеством вложенных элементов, как левых, так и правых списков, и сортировать их по отдельности.
# Такой подход обеспечивает гибкость и эффективность при решении сложных задач сортировки и других алгоритмических операций.

print(quick_sort([5, 2, 9, 0, 1, 5, 3]))





# Сортировка выбором.
# Сортировка выбором работает путем поиска минимального элемента в неотсортированной части массива и его обмена с первым элементом этой части.
# Затем процесс повторяется для оставшейся части массива.

# 1. Создаем список a
a = [-3, 5, 0, -8, 1, 10]


# 2. Мы будем передавать наш массив в функцию selection_sort
def selection_sort(arr):

# 3. Используем цикл for, чтобы пройтись по всему списку,
# а также используем функцию range, чтобы узнать, сколько проходов необходимо сделать.
# Часть кода (len(arr)) определяет длину списка, который мы будем передавать в функцию selection_sort.
    for i in range(len(arr)):
# 4. Мы предполагаем, что первый элемент в неотсортированной части — это минимальный элемент.
# В переменную i сохранился нулевой индекс, сейчас мы берём значение -3, а затем, используя цикл for ищем минимальное значение в оставшемся массиве.
# Так как значение i мы не рассматриваем, то берем i+1.
        min_index = i
        for j in range(i+1, len(arr)):
# 5. Далее прописываем условие: если элемент, который мы нашли в списке arr[j] будет меньше,
# чем элемент с минимальным индексом (который у нас сейчас сохранен как минимальный индекс), то мы значение минимального индекса меняем на j
            if arr[j] < arr[min_index]:
                min_index = j
# 6. Теперь замену необходимо произвести в списке.
# Меняем местами найденный минимальный элемент с первым элементом в неотсортированной части массива
        arr[i], arr[min_index] = arr[min_index], arr[i]
# 7. Теперь используем функцию, прописав вызов
selection_sort(a)
print(a)







# Алгоритм сортировки вставками
# Сортировка вставками работает путем последовательного перемещения элементов массива,
# вставляя каждый элемент на его правильное место в уже отсортированной части массива
a = [-3, 5, 0, -8, 1, 10]
# 1. Создадим функцию def → назовем ее insert_sort → в круглых скобках укажем массив (arr)
def insert_sort(arr):

# 2. Используем цикл for, который проходит по всем элементам списка от индекса**1** до максимальной длины массива.
    for i in range(1, len(arr)):

# 3. Сохраняем текущий элемент в переменной key
        key = arr[i]

# 4. Для сравнения текущей переменной с отсортированными сохраняем индекс предыдущего элемента в переменной j (для сравнения)
        j = i-1
# 5. Прописываем цикл while, который перемещает элементы больше текущего элемента,
# сохраненного в key на одну позицию вправо, чтобы освободить место для вставки key:
# прописываем while;
# указываем условие продолжения цикла, чтобы не выйти за границы списка j >= 0 ;
# объединяем еще с одним условием, при котором текущий элемент больше key, т.е. arr[j] > key.
        while j >= 0 and arr[j] > key:

# 6. Сдвигаем элемент arr[j] вправо на одну позицию и указываем переход к следующему элементу влево
            arr[j+1] = arr[j]
            j -=1
# 7. Вставляем текущий элемент, на котором находится цикл на правильное место
        arr[j+1] = key
# 8. Тестируем алгоритм:
# вызываем функцию insert_sort(arr);
# выводим результат через print(a)
insert_sort(a)
print(a)
