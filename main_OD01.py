# Алгоритм для нахождения максимального/минимального числа
# Попробуем построить сначала простые алгоритмы.
# Возьмём за пример программу для нахождения максимального числа в массиве.
# Сначала пропишем алгоритм словами, а уже затем на его основе создадим программу.
# Создаем переменную для хранения максимального элемента массива.
# Перебираем весь массив, чтобы работать с каждым элементом по отдельности.
# На каждом шаге сравниваем текущий элемент с переменной максимального значения.
# Сохраняем самый первый элемент массива в эту переменную, после чего сравниваем это значение с каждым элементом массива.
# Если текущий элемент больше максимального значения, заменяем максимальное значение.
# Возвращаем максимальное значение после окончания цикла.
# В конце цикла получаем максимальное значение массива.

def find_max(list):
    max_number = list[0]
    for i in list:
        if i > max_number:
            max_number = i
    return max_number

# Перепишем только что созданный фрагмент кода, настроив его на нахождение минимального числа. Алгоритм будет таким:
# Мы создадим переменную, но уже минимального числа:
# Создаем переменную для хранения минимального числа в массиве.
# Перебираем массив с помощью цикла.
# Сравниваем текущий элемент с минимальным значением в переменной.
# Если текущий элемент меньше минимального, то заменяем минимальное значение.
# Возвращаем минимальное значение после окончания цикла.

def find_min(list):
    min_number = list[0]
    for i in list:
        if i < min_number:
            min_number = i
    return min_number

numbers = [56, 74, 23, 98, 143, -89, -23]

print(find_max(numbers))
print(find_min(numbers))

# Факториал 5: 5! = 1 * 2 * 3 * 4 * 5 = 120
# Для начала проверим, равно ли число 0 — в этом случае факториал этого числа по определению равен 1.
# Снова создадим план действий:
# Сравнение числа с нулем: если число равно 0, то факториал нуля будет равен 1.
# Создание переменной для хранения итогового результата.
# Использование цикла for и range для перебирания списка из чисел до нашего числа включительно, у которого мы ищем факториал.
# Домножение результирующей переменной на текущее число в цикле.
# Возврат факториала числа после цикла.

def factorial(number):
    if number == 0:
        return 1
    result = 1
    for i in range(1, number + 1):
        result *= i
    return result
# Рассмотрим пошагово, как работает наш алгоритм:
# Возьмем для примера число 5.
# Передаем это число функции. Так как 5 не равно 0, условие проверки на ноль нам не подходит.
# Устанавливаем начальное значение результирующей переменной равным 1.
# Перебираем список от 1 до 5 включительно.
# На каждом шаге цикла перемножаем текущее значение результирующей переменной с текущим числом из списка.
# После завершения цикла возвращаем итоговое значение результирующей переменной.
# Первый шаг: result = 1 * 1 = 1
# Второй шаг: result = 1 * 2 = 2
# Третий шаг: result = 2 * 3 = 6
# Четвертый шаг: result = 6 * 4 = 24
# Пятый шаг: result = 24 * 5 = 120
print(factorial(1))
print(factorial(5))
print(factorial(7))
print(factorial(12))



# Нахождение простого числа
# 2 - делится на 1 и на 2
# 3 - делится на 1 и на 3
# 5 - делится на 1 и на 5
# Это простые числа

# Непростые числа:
# 4 - делится на 1, на 2, на 4
# 6 - делится на 1, на 2, на 3, на 6

# Проверяем, меньше или равно ли число 1 единице. Если да, то возвращаем false.
# Создаем цикл, перебирающий все числа от 2 до квадратного корня из нашего числа включительно (так как 2 — это первое простое число).
# Проверяем, делится ли наше число на какое-то из чисел, которые перебирает цикл, без остатка. Если да, то возвращаем false.
#
# Существует правило: если число делится на некоторое число, большее своего квадратного корня,
# то оно обязательно будет делиться и на число, меньшее своего квадратного корня.
# Мы используем это правило, чтобы сократить количество проверок.
# Если число делится на любое из чисел в этом диапазоне, мы возвращаем false, так как оно не является простым.

# Если число прошло все проверки, возвращаем true.
import math

def is_prime(number):
    if number <= 1:
        return False

    for i in range(2, int(math.sqrt(number))+1): # math.sqrt(number)) - находим квадратный корень
        if number % i == 0:
            return False
    return True

print(is_prime(17))


# Палиндром — это строка, которая читается одинаково слева направо и справа налево
# Чтобы это проверить, нужно сравнить строку с её перевёрнутой версией
# 1) Получи строку s (ввод пользователя или аргумент функции)
# 2) Приведи строку к единому виду: s = s.lower() (чтобы не зависеть от регистра)
# 3) Убери пробелы по краям: s = s.strip()
# 4) Если по условию нужно игнорировать пробелы внутри — удали их (например, заменить " " на "")
# 5) Если по условию нужно игнорировать знаки препинания — оставь только буквы/цифры (отфильтруй символы)
# 6) Создай перевёрнутую версию строки: reversed_s = s[::-1]
# 7) Сравни исходную и перевёрнутую строки: если s == reversed_s, то это палиндром
# 8) Если равны — выведи/верни True (или сообщение "палиндром")
# 9) Если не равны — выведи/верни False (или сообщение "не палиндром")
def palindrome(s):
    s = s.lower()
    s = s.strip()
    reversed_s = s[::-1]
    if s == reversed_s:
        return True
    return False

print(palindrome('Madam'))
