# Константная сложность
# O(1) - константная сложность
# Константная сложность означает, что время выполнения алгоритма не зависит от размера входных данных

# Напишем простую функцию для доступа к элементу по индексу, то есть к элементам списка по индексу.
# 1. Для этого создадим функцию getElement и передадим в нее список и индекс элемента; на следующей строке возвратим элемент по индексу:
def get_element(arr, index):
    return arr[index]
# Этот алгоритм имеет константную сложность, так как время выполнения не зависит от размера массива

# 2. Пропишем пример использования: создадим массив (список) и пропишем команду print для вывода элемента, например, 4:
arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]
print(get_element(arr, 4))

# Таким образом, мы передаем здесь в функцию и сам массив, и индекс 4






# Линейная сложность
# Линейная сложность алгоритма обозначается как O(n):
# O(n) - линейная сложность алгоритма
# Линейная сложность алгоритма означает, что время выполнения алгоритма пропорционально количеству входных данных

# 1. функцию для поиска элемента в массиве. Для этого:
# создадим функцию lineSearch и передадим в нее массив и цель внутри него;
# используем цикл for, чтобы перебрать весь список;
# пропишем условие для сравнения элемента с искомым (целевым) элементом с возвращением переменной i;
# пропишем возврат значения для случаев, когда целевой элемент не будет найден (пусть в этом случае возвращается значение -1).
def line_search(arr, target):
    for i in range(len(arr)):
        if arr[i] == target:
            return i
    return  -1

# 2. Пропишем пример кода для использования этой функции:
# создадим список;
# выведем функцию line_search, передав внутри нее массив и целевое число — например, 30;
# пропишем еще одну такую же строчку, однако здесь передадим целевое число, которого нет в массиве — например, 60.
arr = [10, 20, 30, 40, 50]
print(line_search(arr, 30))
print(line_search(arr, 60))
# Запустим код. В результате выведется индекс указанного числа: в нашем примере это 2. Во втором случае выведется -1, поскольку числа 60 нет в списке.







# Логарифмическая сложность
# Рассмотрим логарифмическую сложность, обозначаемую как O(log n):
# O(log n) = логарифмическая сложность алгоритма
# ✅Логарифмическая сложность означает, что время выполнения алгоритма увеличивается логарифмически с увеличением размера входных данных
# Логарифм — это количество шагов, которые требуется проделать для получения результата

# Перейдем к написанию кода для логарифмической сложности алгоритма.
# 1. Создадим функцию, назовем ее binary_search, и передадим в нее массив и элемент, который нужно найти в этом массиве:
def binary_search(arr, target):


# 2. Создадим две переменные: low для начального индекса массива (0) и high для конечного индекса массива, который равен длине массива -1.
# Это связано с тем, что индексация в массивах начинается с 0.
# Таким образом, если в массиве пять элементов, последний элемент будет иметь индекс 4, а не 5.
# Следовательно, чтобы указать последний элемент массива, мы вычитаем 1 из длины массива:
    low, high = 0, len(arr) - 1

# 3. Создадим цикл поиска, который продолжается, пока начальный индекс меньше или равен конечному.
# Внутри цикла мы находим середину массива.
# Для этого складываем начальный и конечный индексы и делим их на 2 (двойной слэш означает целочисленное деление):
    while low <= high:
        mid = (low+high) // 2

# 4. Сравним элемент в середине массива с целевым значением. Если они равны, возвращаем индекс среднего элемента:
        if arr[mid] == target:
            return mid

# 5. Если средний элемент меньше целевого значения, это значит, что целевой элемент находится в правой половине массива.
# Чтобы перейти в правую часть, мы должны начальную часть массива перенести с нулевого индекса чуть правее,
# чем значение mid, и таким образом в low сохранится новое начало отрезка, с которым мы работаем:
        elif arr[mid] < target:
            low = mid + 1


# 6. Если средний элемент больше целевого значения, значит, целевой элемент находится в левой половине массива.
# Тогда конечный индекс (high) устанавливаем на mid - 1.
        else:
            high = mid - 1

# 7. Если цикл завершился, а элемент не найден, возвращаем -1.
    return -1


# 8. Перейдем к использованию этой функции:
# Передадим в функцию массив;
# Вызовем функцию, передадим в нее массив и зададим целевое число — например, 70;
# Повторим строку, но зададим число, которого нет в массиве — например, 25.
arr = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]
print(binary_search(arr, 70))
print(binary_search(arr, 25))

# 10. Запускаем код и видим, что в первом случае выводится индекс элемента 70 (в нашем списке это индекс 6)
# и во втором случае получаем -1, поскольку числа 25 нет в заданном массиве.